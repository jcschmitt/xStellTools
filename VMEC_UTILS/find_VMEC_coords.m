function [rho, theta, dr_drho, dr_dtheta, dr_dphi, dz_drho, dz_dtheta, ...
    dz_dphi, output_flag] = find_VMEC_coords(rho_in, theta_in, ...
    r, z, phi, tolinv, mnmax, xm, xn, spline_vmec, spline_d_vmec, torflux_LCFS)
% find_VMEC_coords finds the radial and poloidal VMEC flux
% coordinates of a point specified in cylindrical coordinates
%References:
%  Attenberger, Houlberg, Hirshman J Comp Phys 72 (1987) 435
%  Original Fortran (traflx) by W.A. Houlberg 12/97
%  Adapted by JC Schmitt for Matlab  11/2009
%Input:
%  rho_in, theta_in - initial guesses
%  r - major radius (m)
%  z - vertical coordinate (m)
%  phi - toroidal angle, right-hand rule around z-direction (radians)
%  tolinv - convergence tolerance on r and z (m)
%     = 1.0e-5*plasma minor radius is suggested (m)
%  mnmax-total number of modes
%  xm-poloidal mode #s
%  xn-toroidal mode #s
%  spline_vmec - spline coeffiecinets structure for each mode iota, lmns,
%       rmnc, zmns
%  spline_d_vmec - spline coeffiecinets structure for radial derivatives
%       of each mode of rmnc, zmns
%  torflux_LCFS-The enclosed toroidal flux at the last closed flux surface.
%Output:
%  rho - flux surface label (-)
%  theta -poloidal coordinate theta (radians)
%  dr_drho - dr/drho (m)
%  dr_dtheta - dr/dtheta (m/radian)
%  dr_dphi - dr/dphi (m/radian)
%  dz_drho - dz/drho (m)
%  dz_dtheta - dz/dtheta (m/radian)
%  dz_dphi - dz/dphi (m/radian)
%  output_flag - error flag (-)
%       = 0 normal return, rho and theta within plasma
%       = 1 converged to point outside plasma
%       > 1 = no. of iterations, did not converge
%       > 100 = 100 + no. iterations, no solution
%       > 200 = 200 + no. iterations, Jacobian problems
%Comments:
%  The input values of rho and theta are used for the initial guess.
%  The basic method is a Newton iteration in 2 dimensions.  See the paper
%  for details.  Point _bg is the previous best guess and point _tp is a
%  trial point.  If _tp is further from (r,z) than _bg, a new trial
%  point is generated by halving the step and using interpolated derivatives
%======================================================

max_iter = 100;
output_flag = NaN;
%  Physical and conversion constants
precision_1 = 2.0e-7; % used in cases when too close to rho == 0
% Set starting points and parameters
dtheta_max = 0.5;
halfs = 1;
tau_bg = 0; % used to track the sign of the Jacobian.  Set to +/- during first iteration
error_to_bg = Inf;

rho_bg = rho_in;
theta_bg = theta_in;
rho_tp = rho_bg;
theta_tp = theta_bg;

if rho_tp == 0.0
    rho_tp = 1.0e-2;
end

% Iterate to find flux coordinates
continue_iterating = 1;
% recovery_attempt = 0;
num_iter = 0;
while continue_iterating
    num_iter = num_iter + 1;
    
    
    % find r, z and derivs for current trial point
    [r_tp, z_tp, r_rho_tp, r_theta_tp, r_phi_tp, z_rho_tp, z_theta_tp, ...
        z_phi_tp] = ...
        get_VMEC_inverse_coords(rho_tp, theta_tp, phi, mnmax, xm, xn, ...
        spline_vmec, spline_d_vmec, torflux_LCFS);
    
    % debugging info
    r_debug(num_iter) = r_tp;
    z_debug(num_iter) = z_tp;
    
    % check distance from r, z, to the trial point
    dr_tp = (r - r_tp);
    dz_tp = (z - z_tp);
    error_to_tp = dr_tp^2 + dz_tp^2;
    %     sqrt(error_to_tp)
    
    %  Check convergence
    if ( (abs(dr_tp) <= tolinv) && (abs(dz_tp) <= tolinv) )
        %         disp(['num_iter = ' num2str(num_iter)]);
        %         continue_iterating = 0; %used in some debugging cases
        % set output flag
        if (rho_tp > 1.0)
            output_flag = 1;
        else
            output_flag = 0;
        end
        
        rho = rho_tp;
        theta = mod(theta_tp, 2*pi);
        dr_drho = r_rho_tp;
        dr_dtheta = r_theta_tp;
        dr_dphi = r_phi_tp;
        dz_drho = z_rho_tp;
        dz_dtheta = z_theta_tp;
        dz_dphi = z_phi_tp;
        return
    end
    
    % Not converged.  Now what?
    
    % Need to improve the estimate for rho and theta - try to get new Jacobian
    if (rho_tp == 0.0)
        rho_tp = 10.0 * precision_1;
    end
    
    tau_tp = z_rho_tp * r_theta_tp - r_rho_tp * z_theta_tp;
    
    if  (abs(tau_tp) < 1.0e-37)
        % No solution exists for the Newton method
        % Assume the solution is at the origin where tau = 0
        continue_iterating = 0;
        output_flag = 100 + iteration;
        disp('<---Axis found?'); % Note: fix this iff it ever occurs.
        rho = 0.0; % it was 1.0;  % JCS: Shouldn't this be '0.0'?
        theta = 0.0;
    end
    
    %  Check consistency of sign of Jacobian
    if ((sign(tau_tp) ~= sign(tau_bg)) && tau_bg ~= 0.0)
        % Bad data.  Give up.
        output_flag = 200 + num_iter;
        %disp(['<----Entering ''bad jacobian'' region'])
        continue_iterating = 0;
        rho = NaN; %1.0;  % this could also be set to NaN?
        theta = NaN; %0.0;  % this could also be set to NaN?
        dr_drho = NaN;
        dr_dtheta = NaN;
        dr_dphi = NaN;
        dz_drho = NaN;
        dz_dtheta = NaN;
        dz_dphi = NaN;
        return;
    end
    
    % If converging, set the best guess equal to the test point.
    %  Otherwise, halve the step size.
    if (error_to_tp < error_to_bg)
        %         Converging - set trial point = best guess
        if (halfs > 1)
            %if recovery_attempt
            %    halfs = halfs / 2;
            %    recovery_attempt = 0;
            %else
            halfs = halfs / 2;
            %end
        end
        rho_bg = rho_tp;
        theta_bg = theta_tp;
        error_to_bg = error_to_tp;
        r_rho_bg = r_rho_tp;
        z_rho_bg = z_rho_tp;
        r_theta_bg = r_theta_tp;
        z_theta_bg = z_theta_tp;
        tau_bg = tau_tp;
        dr_bg = dr_tp;
        dz_bg = dz_tp;
    else
        %         Not converging - halve step size
        halfs = halfs * 2;
    end
    
    % Compute rho and theta steps - _bg and _tp may coincide here.
    % If the process is converging, all of these 1/4 and 3/4 do nothing
    % except set r_rho (or whatever) to r_rho_tp, etc., as expected for
    % a normal Newton search.  However, if the process is not
    % converging, an alternate jacobian and step size (halved) is used
    r_rho = 0.75 * r_rho_bg + 0.25 * r_rho_tp;
    z_rho = 0.75 * z_rho_bg + 0.25 * z_rho_tp;
    r_theta = 0.75 * r_theta_bg + 0.25 * r_theta_tp;
    z_theta = 0.75 * z_theta_bg + 0.25 * z_theta_tp;
    tau = 0.75 * tau_bg + 0.25 * tau_tp;
    dr = dr_tp / halfs;
    dz = dz_tp / halfs;
    drho = (r_theta * dz - z_theta * dr) / tau;
    dtheta = (z_rho * dr - r_rho * dz) / tau;
    
    % Avoid jumping around in poloidal space too far
    if  abs(dtheta) > dtheta_max
        dtheta = abs(dtheta_max) * sign(dtheta);
    end
    
    % Get new trial point
    rho_tp = rho_bg + drho;
    theta_tp = theta_bg + dtheta;
    
    % check to keep rho positive.
    if (rho_tp < 0.0)
        rho_tp = -rho_tp;
        theta_tp = theta_tp + pi - 2 * dtheta;
    end
    
    % check max number of iterations.  Pass back the current trial point
    if num_iter >= max_iter
        disp(['<----find_VMEC_coords not converged. using last test_point. num_iter = ' num2str(num_iter)]);
        disp(['<----(R, Z, Phi) = ' num2str([r z phi])]);
        continue_iterating = 0;
        rho = rho_tp;
        theta = mod(theta_tp, 2*pi);
        dr_drho = r_rho_tp;
        dr_dtheta = r_theta_tp;
        dr_dphi = r_phi_tp;
        dz_drho = z_rho_tp;
        dz_dtheta = z_theta_tp;
        dz_dphi = z_phi_tp;
        output_flag = num_iter;
    end
end % while continue_iteration ...
