function [Bx,By,Bz,BR,BPhi] = calc_b_W7X(P_x, P_y, P_z, coil_current_array)
%function [Bx,By,Bz,Br,Bphi] = calc_b_W7X(P_x, P_y, P_z, 

% Input: Px, Py, Pz:  Cartesian coordinates of the observation point
%        coil_current_array:  An array of 14 elements that specify the coil
%        current in the following order:
%                [Coil_1 Coil_2 Coil_3 Coil_4 Coil_5 Coil_A Coil_B
%                Sweep_Coil_1 Sweep_Coil_2 TRIM_A1 TRIM_B1 TRIM_A2 TRIM_A3
%                TRIM_A4]
%
% Output:  Bx, By, Bz:  Magnetic flux density (T/m) at observation point
%          Br, Bphi: Bx and By are used to find radial and toroidal
%          components.
%
% Calculates cartesian B field from given cartesian lab frame
% coordinates and coil current array.  If the observation point lies
% on a current filament (or extremely close) the contribution from that
% filament is ignored.
%
% The file W7X_coils.mat must be available.
%

% The details of the W7X coils are stored in this persistent array
persistent W7X_coils

if isempty(W7X_coils)  % load the LTX coil information if necessary
    W7X_coils = load_W7X_coils;
end

if length(coil_current_array) ~= 14
    error('The coir_current_arrray must have 14 elements');
end

% Calculate the B field due to each individual coil set
%
% NOTICE!!! Each coil has a multiplicative factor to account for the actual
% number of turns in the coils - Some (All?) coils have multiple turns, but
% only the centroid is listed
% The coils.w7x file specifies the center of the coil path and also the
% scaling factor to account for the total number of turns. The mutual
% inductance calculation from V3RFUN includes this term.
% The Trim Coils (AAQ**) are NOT treated this way. They are specified as
% single turns with 1 A current. The currents and inductance calculations
% need to be scaled by (48 or 72) to account for this different treatement.

% WF_ : winding factors
WF_Coil_1 = 108;
WF_Coil_2 = 108;
WF_Coil_3 = 108;
WF_Coil_4 = 108;
WF_Coil_5 = 108;
WF_Coil_A = 36;
WF_Coil_B = 36;
WF_Sweep_Coil_1 = 8;
WF_Sweep_Coil_2 = 8;
WF_TRIM_A1 = 48;
WF_TRIM_A2 = 48;
WF_TRIM_A3 = 48;
WF_TRIM_A4 = 48;
WF_TRIM_B1 = 72;

[Bx_Coil_1, By_Coil_1, Bz_Coil_1] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_1, coil_current_array(1));

[Bx_Coil_2, By_Coil_2, Bz_Coil_2] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_2, coil_current_array(2));

[Bx_Coil_3, By_Coil_3, Bz_Coil_3] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_3, coil_current_array(3));

[Bx_Coil_4, By_Coil_4, Bz_Coil_4] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_4, coil_current_array(4));

[Bx_Coil_5, By_Coil_5, Bz_Coil_5] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_5, coil_current_array(5));

[Bx_Coil_A, By_Coil_A, Bz_Coil_A] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_A, coil_current_array(6));

[Bx_Coil_B, By_Coil_B, Bz_Coil_B] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Coil_B, coil_current_array(7));

[Bx_Sweep_Coil_1, By_Sweep_Coil_1, Bz_Sweep_Coil_1] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Sweep_Coil_1, coil_current_array(8));

[Bx_Sweep_Coil_2, By_Sweep_Coil_2, Bz_Sweep_Coil_2] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.Sweep_Coil_2, coil_current_array(9));

[Bx_TRIM_A1, By_TRIM_A1, Bz_TRIM_A1] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.TRIM_A1, coil_current_array(10));

[Bx_TRIM_B1, By_TRIM_B1, Bz_TRIM_B1] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.TRIM_B1, coil_current_array(11));

[Bx_TRIM_A2, By_TRIM_A2, Bz_TRIM_A2] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.TRIM_A2, coil_current_array(12));

[Bx_TRIM_A3, By_TRIM_A3, Bz_TRIM_A3] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.TRIM_A3, coil_current_array(13));

[Bx_TRIM_A4, By_TRIM_A4, Bz_TRIM_A4] = ...
    calc_B_BiotSavart(P_x, P_y, P_z, W7X_coils.TRIM_A4, coil_current_array(14));


% Add them together.
Bx = WF_Coil_1 * Bx_Coil_1 + ...
    WF_Coil_2 * Bx_Coil_2 + ...
    WF_Coil_3 * Bx_Coil_3 + ...
    WF_Coil_4 * Bx_Coil_4 + ...
    WF_Coil_5 * Bx_Coil_5 +...
    WF_Coil_A * Bx_Coil_A +...
    WF_Coil_B * Bx_Coil_B + ...
    WF_Sweep_Coil_1 * Bx_Sweep_Coil_1 + ...
    WF_Sweep_Coil_2 * Bx_Sweep_Coil_2 + ...
    WF_TRIM_A1 * Bx_TRIM_A1 + ...
    WF_TRIM_A2 * Bx_TRIM_A2 + ...
    WF_TRIM_A3 * Bx_TRIM_A3 + ...
    WF_TRIM_A4 * Bx_TRIM_A4 + ...
    WF_TRIM_B1 * Bx_TRIM_B1;

By = WF_Coil_1 * By_Coil_1 + ...
    WF_Coil_2 * By_Coil_2 + ...
    WF_Coil_3 * By_Coil_3 + ...
    WF_Coil_4 * By_Coil_4 + ...
    WF_Coil_5 * By_Coil_5 +...
    WF_Coil_A * By_Coil_A +...
    WF_Coil_B * By_Coil_B + ...
    WF_Sweep_Coil_1 * By_Sweep_Coil_1 + ...
    WF_Sweep_Coil_2 * By_Sweep_Coil_2 + ...
    WF_TRIM_A1 * By_TRIM_A1 + ...
    WF_TRIM_A2 * By_TRIM_A2 + ...
    WF_TRIM_A3 * By_TRIM_A3 + ...
    WF_TRIM_A4 * By_TRIM_A4 + ...
    WF_TRIM_B1 * By_TRIM_B1;

Bz = WF_Coil_1 * Bz_Coil_1 + ...
    WF_Coil_2 * Bz_Coil_2 + ...
    WF_Coil_3 * Bz_Coil_3 + ...
    WF_Coil_4 * Bz_Coil_4 + ...
    WF_Coil_5 * Bz_Coil_5 +...
    WF_Coil_A * Bz_Coil_A +...
    WF_Coil_B * Bz_Coil_B + ...
    WF_Sweep_Coil_1 * Bz_Sweep_Coil_1 + ...
    WF_Sweep_Coil_2 * Bz_Sweep_Coil_2 + ...
    WF_TRIM_A1 * Bz_TRIM_A1 + ...
    WF_TRIM_A2 * Bz_TRIM_A2 + ...
    WF_TRIM_A3 * Bz_TRIM_A3 + ...
    WF_TRIM_A4 * Bz_TRIM_A4 + ...
    WF_TRIM_B1 * Bz_TRIM_B1;


% The other useful values.
P_phi = atan2(P_y, P_x);
BR = Bx .* cos(P_phi) + By .* sin(P_phi);
BPhi = By .* cos(P_phi) - Bx .* sin(P_phi);
